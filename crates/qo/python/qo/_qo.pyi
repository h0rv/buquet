# Type stubs for the qo native module.

from collections.abc import Callable, Coroutine, Sequence
from typing import Any

from qo.typing import TaskSchema

class WorkerConfig:
    @property
    def poll_interval_ms(self) -> int | None: ...
    @property
    def index_mode(self) -> str | None: ...
    @property
    def shards(self) -> list[str] | None: ...

class MonitorConfig:
    @property
    def check_interval_secs(self) -> int | None: ...
    @property
    def sweep_interval_secs(self) -> int | None: ...

class Config:
    @property
    def bucket(self) -> str: ...
    @property
    def endpoint(self) -> str | None: ...
    @property
    def region(self) -> str: ...
    @property
    def worker(self) -> WorkerConfig: ...
    @property
    def monitor(self) -> MonitorConfig: ...

def py_load_config(profile: str | None = None) -> Config: ...

class PollingStrategy:
    @staticmethod
    def fixed(interval_ms: int = 500) -> PollingStrategy: ...
    @staticmethod
    def adaptive(
        min_interval_ms: int = 100,
        max_interval_ms: int = 5000,
        backoff_multiplier: float = 2.0,
    ) -> PollingStrategy: ...

class ShardLeaseConfig:
    @staticmethod
    def disabled() -> ShardLeaseConfig: ...
    @staticmethod
    def enabled() -> ShardLeaseConfig: ...
    @staticmethod
    def custom(
        shards_per_worker: int = 16,
        lease_ttl_secs: int = 30,
        renewal_interval_secs: int = 10,
    ) -> ShardLeaseConfig: ...
    @property
    def is_enabled(self) -> bool: ...
    @property
    def shards_per_worker(self) -> int: ...
    @property
    def lease_ttl_secs(self) -> int: ...
    @property
    def renewal_interval_secs(self) -> int: ...

class Schedule:
    @property
    def id(self) -> str: ...
    @property
    def task_type(self) -> str: ...
    @property
    def input(self) -> object: ...
    @property
    def cron(self) -> str: ...
    @property
    def enabled(self) -> bool: ...
    @property
    def timeout_seconds(self) -> int | None: ...
    @property
    def max_retries(self) -> int | None: ...
    @property
    def created_at(self) -> str: ...
    @property
    def updated_at(self) -> str: ...
    def to_dict(self) -> dict[str, object]: ...

class ScheduleLastRun:
    @property
    def schedule_id(self) -> str: ...
    @property
    def last_run_at(self) -> str: ...
    @property
    def last_task_id(self) -> str: ...
    @property
    def next_run_at(self) -> str: ...

class TaskStatus:
    Pending: TaskStatus
    Running: TaskStatus
    Completed: TaskStatus
    Failed: TaskStatus
    Cancelled: TaskStatus
    Archived: TaskStatus
    Expired: TaskStatus

class RetryPolicy:
    def __init__(
        self,
        initial_interval_ms: int = 1000,
        max_interval_ms: int = 60000,
        multiplier: float = 2.0,
        jitter_percent: float = 0.25,
    ) -> None: ...
    @property
    def initial_interval_ms(self) -> int: ...
    @property
    def max_interval_ms(self) -> int: ...
    @property
    def multiplier(self) -> float: ...
    @property
    def jitter_percent(self) -> float: ...
    def calculate_delay_ms(self, attempt: int) -> int: ...

class TaskContext:
    @property
    def task_id(self) -> str: ...
    async def extend_lease(self, additional_secs: int) -> None: ...
    async def lease_expires_at(self) -> str | None: ...
    async def refresh(self) -> None: ...
    async def is_cancellation_requested(self) -> bool: ...

class Task:
    @property
    def id(self) -> str: ...
    @property
    def shard(self) -> str: ...
    @property
    def task_type(self) -> str: ...
    @property
    def input(self) -> object: ...
    @property
    def output(self) -> object | None: ...
    @property
    def status(self) -> TaskStatus: ...
    @property
    def timeout_seconds(self) -> int: ...
    @property
    def max_retries(self) -> int: ...
    @property
    def retry_count(self) -> int: ...
    @property
    def retry_policy(self) -> RetryPolicy: ...
    @property
    def created_at(self) -> str: ...
    @property
    def available_at(self) -> str: ...
    @property
    def lease_expires_at(self) -> str | None: ...
    @property
    def lease_id(self) -> str | None: ...
    @property
    def attempt(self) -> int: ...
    @property
    def updated_at(self) -> str: ...
    @property
    def completed_at(self) -> str | None: ...
    @property
    def worker_id(self) -> str | None: ...
    @property
    def last_error(self) -> str | None: ...
    @property
    def input_ref(self) -> str | None: ...
    @property
    def output_ref(self) -> str | None: ...
    @property
    def reschedule_count(self) -> int: ...
    @property
    def max_reschedules(self) -> int | None: ...
    @property
    def cancel_requested(self) -> bool: ...
    @property
    def cancelled_at(self) -> str | None: ...
    @property
    def cancelled_by(self) -> str | None: ...
    @property
    def expires_at(self) -> str | None: ...
    @property
    def expired_at(self) -> str | None: ...
    def can_retry(self) -> bool: ...
    def is_available_at(self, now_rfc3339: str) -> bool: ...
    def is_lease_expired_at(self, now_rfc3339: str) -> bool: ...
    def is_timed_out_at(self, now_rfc3339: str) -> bool: ...
    def is_expired_at(self, now_rfc3339: str) -> bool: ...
    def to_dict(self) -> dict[str, object]: ...

class CancelByTypeResult:
    @property
    def cancelled(self) -> list[Task]: ...
    @property
    def failed(self) -> list[tuple[str, str]]: ...

class StorageClient:
    async def get(self, key: str) -> tuple[bytes, str]: ...
    async def put(
        self,
        key: str,
        data: bytes,
        if_match: str | None = None,
    ) -> str: ...
    async def delete(self, key: str) -> None: ...
    async def list(
        self,
        prefix: str,
        start_after: str | None = None,
        limit: int = 1000,
    ) -> list[str]: ...
    async def exists(self, key: str) -> bool: ...

class Queue:
    async def submit(
        self,
        task_type: str,
        input: object,  # noqa: A002
        timeout_seconds: int | None = None,
        max_retries: int | None = None,
        retry_policy: RetryPolicy | None = None,
        schedule_at: object | None = None,
        use_payload_refs: bool = False,
        payload_ref_threshold_bytes: int | None = None,
        idempotency_key: str | None = None,
        idempotency_ttl_days: int | None = None,
        idempotency_scope: str | None = None,
        max_reschedules: int | None = None,
        ttl_seconds: int | None = None,
        expires_at: object | None = None,
    ) -> Task: ...
    async def now(self) -> str: ...
    async def submit_many(
        self,
        tasks: Sequence[tuple[str, object]],
        timeout_seconds: int | None = None,
        max_retries: int | None = None,
        retry_policy: RetryPolicy | None = None,
        max_reschedules: int | None = None,
        ttl_seconds: int | None = None,
        expires_at: object | None = None,
    ) -> list[Task]: ...
    async def get(self, task_id: str) -> Task | None: ...
    async def list(
        self,
        shard: str,
        status: TaskStatus | None = None,
        limit: int = 100,
    ) -> list[Task]: ...
    async def list_ready(
        self,
        shard: str,
        limit: int = 100,
    ) -> list[str]: ...
    async def get_history(self, task_id: str) -> list[Task]: ...
    async def load_input(self, task: Task) -> object: ...
    async def load_output(self, task: Task) -> object | None: ...
    async def publish_schema(
        self,
        task_type: str,
        schema: TaskSchema,
    ) -> None: ...
    async def get_schema(self, task_type: str) -> TaskSchema | None: ...
    async def list_schemas(self) -> list[str]: ...
    async def delete_schema(self, task_type: str) -> None: ...
    def validate_input(self, schema: TaskSchema, data: object) -> None: ...
    def validate_output(self, schema: TaskSchema, data: object) -> None: ...
    @property
    def shard_prefix_len(self) -> int: ...
    @property
    def storage(self) -> StorageClient: ...
    def all_shards(self) -> list[str]: ...
    async def create_schedule(
        self,
        id: str,  # noqa: A002
        task_type: str,
        input: object,  # noqa: A002
        cron: str,
        timeout_seconds: int | None = None,
        max_retries: int | None = None,
    ) -> Schedule: ...
    async def get_schedule(self, id: str) -> Schedule | None: ...  # noqa: A002
    async def list_schedules(self) -> list[Schedule]: ...
    async def delete_schedule(self, id: str) -> None: ...  # noqa: A002
    async def enable_schedule(self, id: str) -> None: ...  # noqa: A002
    async def disable_schedule(self, id: str) -> None: ...  # noqa: A002
    async def trigger_schedule(self, id: str) -> Task: ...  # noqa: A002
    async def get_schedule_last_run(self, id: str) -> ScheduleLastRun | None: ...  # noqa: A002
    async def cancel(
        self,
        task_id: str,
        reason: str | None = None,
        cancelled_by: str | None = None,
    ) -> Task: ...
    async def cancel_many(
        self,
        task_ids: list[str],
        reason: str | None = None,
        cancelled_by: str | None = None,
    ) -> list[Task]: ...
    async def cancel_by_type(
        self,
        task_type: str,
        reason: str | None = None,
        cancelled_by: str | None = None,
    ) -> CancelByTypeResult: ...
    async def request_cancellation(self, task_id: str) -> Task: ...
    async def mark_expired(self, task_id: str) -> Task: ...

class Worker:
    def __init__(
        self,
        queue: Queue,
        worker_id: str,
        shards: list[str],
    ) -> None: ...
    @property
    def worker_id(self) -> str: ...
    @property
    def shards(self) -> list[str]: ...
    def task(
        self,
        task_type: str,
    ) -> Callable[
        [Callable[..., Coroutine[Any, Any, Any]]], Callable[..., Coroutine[Any, Any, Any]]
    ]: ...
    def on_startup(
        self,
        func: Callable[[], Coroutine[Any, Any, None]],
    ) -> Callable[[], Coroutine[Any, Any, None]]: ...
    def on_shutdown(
        self,
        func: Callable[[], Coroutine[Any, Any, None]],
    ) -> Callable[[], Coroutine[Any, Any, None]]: ...
    def on_success(
        self,
        func: Callable[[Task], Coroutine[Any, Any, None]],
    ) -> Callable[[Task], Coroutine[Any, Any, None]]: ...
    def on_error(
        self,
        func: Callable[[Task, str], Coroutine[Any, Any, None]],
    ) -> Callable[[Task, str], Coroutine[Any, Any, None]]: ...
    def registered_task_types(self) -> list[str]: ...
    async def run(
        self,
        options: WorkerRunOptions | None = None,
    ) -> int: ...

class WorkerRunOptions:
    def __init__(
        self,
        polling: PollingStrategy | None = None,
        poll_interval_ms: int = 1000,
        max_tasks: int | None = None,
        with_monitor: bool = True,
        monitor_check_interval_s: int = 30,
        monitor_worker_health_threshold_s: int = 60,
        monitor_sweep_interval_s: int = 300,
        monitor_sweep_page_size: int = 1000,
        shard_lease_config: ShardLeaseConfig | None = None,
        shard_leasing_enabled: bool = False,
        shard_leasing_shards_per_worker: int = 16,
        shard_leasing_ttl_s: int = 30,
        shard_leasing_renewal_interval_s: int = 10,
    ) -> None: ...
    polling: PollingStrategy | None
    poll_interval_ms: int
    max_tasks: int | None
    with_monitor: bool
    monitor_check_interval_s: int
    monitor_worker_health_threshold_s: int
    monitor_sweep_interval_s: int
    monitor_sweep_page_size: int
    shard_lease_config: ShardLeaseConfig | None
    shard_leasing_enabled: bool
    shard_leasing_shards_per_worker: int
    shard_leasing_ttl_s: int
    shard_leasing_renewal_interval_s: int

async def connect(
    endpoint: str | None = None,
    bucket: str | None = None,
    region: str | None = None,
    shard_prefix_len: int | None = None,
) -> Queue: ...

class metrics:  # noqa: N801
    @staticmethod
    def enable_prometheus(port: int = 9000) -> None: ...
    @staticmethod
    def enable_statsd(host: str = "127.0.0.1", port: int = 8125) -> None: ...
    @staticmethod
    def enable_opentelemetry(endpoint: str = "http://localhost:4317") -> None: ...
    @staticmethod
    def auto_configure() -> bool: ...
    @staticmethod
    def current_exporter() -> str | None: ...
